#  Copyright (C) 2013 Intel Corporation
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#
#  *  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  *  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in
#     the documentation and/or other materials provided with the
#     distribution.
#  *  Neither the name of Intel Corporation nor the names of its
#     contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
#  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
#  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
#  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.



##
# \file perf_speedup_plot.py
#
# \brief [<i>Performance test script</i>]: Reads in N data files, and
# generates a set of gnuplot scripts for creating speedup plots.

# This script creates a gnuplot script for each key that shows up in
# the data files.
#
# \author  Jim Sukha
# \version 1.02


import os
import sys

from PerfDataPoint import *
import PerfDataSet
import PerfDataParser


## Generates a list of commands forming the header for a gnuplot
#  script.
#  These commands tell the script to create an output file.
#  with the specified name and extension.
#
# Creates a gnuplot script that creates a file with name
# <title>_plot.<output_extension>.
def generate_gnuplot_header(title, fname, output_extension="png"):
    cmds = []
    cmds.append("# %s  Autogenerated GNUplot for %s.  " % (fname, title))
    cmds.append("reset")
    cmds.append("set title \"Speedup for %s\"" % title)
    cmds.append("set xlabel \"P\"")
    cmds.append("set ylabel \"Speedup\"")
    cmds.append("set key width -1")
    cmds.append("set key auto")

    if (output_extension == "png"):
        cmds.append("set terminal pngcairo color dashed lw 3")
    elif (output_extension == "eps"):
        cmds.append("set terminal postscript enhanced color dashed lw 3")
    else:
        print "ERROR! unrecognized extension..."
        output_extension = "png"
        cmds.append("set terminal pngcairo color dashed lw 3")

    cmds.append("set out \"%s_plot.%s\"" % (title, output_extension))
    return cmds

## Generates a gnuplot .plt script and associated files for a speedup
## plot.
def generate_gnuplot_for_speedup(title,
                                 speedup_map,
                                 outdir="gplot_output"):
    gnuplot_cmds = []

    # Calculate names of the output files.
    (title_head, title_tail) = os.path.split(title)

    plot_fname = "%s_plot.plt" % title_tail
    full_plot_fname = os.path.join(title_head, outdir, plot_fname)
    
    data_fname = "%s_speedup_data.tmpdata" % title_tail
    full_data_fname = os.path.join(title_head, outdir, data_fname)

    data_file_contents = []

    gnuplot_cmds.append("###########################################")
    gnuplot_cmds = gnuplot_cmds + generate_gnuplot_header(title, plot_fname)
    
    n = 0
    plot_cmds = []
    for desc in speedup_map:
        data_string = ""
        points = sorted((speedup_map[desc]))

        if (len(points) > 0):
            sanitized_desc = desc.replace("_", "-")

            data_file_contents.append("# Data for %s, %s" % (title, desc))
            data_file_contents.append("# P,  Speedup")
            plot_cmds.append("\"%s\" index %d using 1:2 with linespoints title \"%s\" " % (data_fname,
                                                                                           n,
                                                                                           sanitized_desc))
            n = n + 1

            for (P, speedup) in points:
                data_file_contents.append("%d     %f   " % (P, speedup))

            # Two blank lines in the data file to separate blocks.
            data_file_contents.append("")
            data_file_contents.append("")

    if plot_cmds:
        plot_cmd = "plot " + ", \\\n".join(plot_cmds)
        print "plot command is %s" % plot_cmd
        gnuplot_cmds.append(plot_cmd)
    else:
        print "WARNING: no data for plot key %s..." % title
        
    gnuplot_cmds.append("###########################################")

    # Now spit the scripts out to a file.
    os.system("mkdir -p %s" % outdir)
    print "## Generating gnuplot plot script %s.. " % plot_fname
    plot_f = open(full_plot_fname, "w")
    for cmd in gnuplot_cmds:
        plot_f.write("%s\n" % cmd)
    plot_f.write("\n")
    plot_f.close()
    
    print "##\n\n"
    print "# Generating data file %s..  " % data_fname
    data_f = open(full_data_fname, "w")
    for line in data_file_contents:
        data_f.write("%s\n" % line)
    data_f.write("\n")
    data_f.close()
        


## Generate all plots from a set of keys, and 
#    
# @param plot_keys   The list of all keys used to generate plots
# @param all_maps A set of (@c desc, @c plot_map) pairs, where @c desc
#                 is a string describing a dataset to plot and @c
#                 plot_map is the map from a plot_key to the list of
#                 points to plot
#
def generate_all_speedup_plots(plot_keys,
                               all_maps):
    for pkey in plot_keys:
        print "# Generating plot for pkey: "
        print pkey
        local_points = []

        for (desc, plot_map) in all_maps:
            if pkey in plot_map:
                desc_points = plot_map[pkey]
            else:
                desc_points = []

            local_points = local_points + desc_points

        if (len(local_points) > 0):
            # If there is at least one data point, generate a plot.
            # Determine min and max values of P.
            min_P = min(set( [ pt.get_P() for pt in local_points ]))
            max_P = max(set( [ pt.get_P() for pt in local_points ]))

            # Find the fastest time that we have data for.
            # (Usually, we will have min_P == 1, and thus this would be the serial time).
            # But if not, it will be
            min_serial_time = min(set( pt.get_time() for pt in local_points if (pt.get_P()  == min_P)))

            # Normalize our speedup, if our speedup is for a value of min_P > 1.
            # This normalization assumes our fastest data point achieves
            # perfect speedup.
            if min_P > 0:
                min_serial_time = min_serial_time * min_P

            # Build a speedup map.
            #
            # speedup_map  maps the description string to the list of
            #  data points (P, time) that we want to plot.
            speedup_map = { }
            for (desc, plot_map) in all_maps:
                print "Plot map for desc = %s" % desc
                if pkey in plot_map:
                    speedup_points = [ (pt.get_P(), min_serial_time / pt.get_time())
                                       for pt in plot_map[pkey]
                                       if (pt.get_time() != 0) ]
                    speedup_map[desc] = speedup_points


            # Spit out a gnuplot script.
            generate_gnuplot_for_speedup(PerfDataPoint.extract_plot_key_string(pkey),
                                         speedup_map)



##
# This script generates a speedup plot from a list of input data files."
#            
# The data files should be stored in the Cilkpub format.
# See @ref PerfDataPoint.py for details.
#            
# Usage: <this script> <f1> <f2> .. <fn>"
#
def main(arglist):
    file_list = []
    data_list = []

    if (len(arglist) <= 1):
        print "This script generates a speedup plot from a list of input data files."
        print "The data files should be stored in the Cilkpub format."
        print "See PerfDataPoint.py for details.\n"
        print "Usage: %s <f1> <f2> .. <fn>" % arglist[0]
        exit(0)
    else:
        file_list = arglist[1:len(arglist)]
        for f in file_list:
            data = PerfDataParser.parse_data_file(f,
                                                  default_desc=f,
                                                  merge_type=PerfDataPoint.MERGE_SUM,
                                                  compute_average=False)
            data.compute_avg_without_minmax()
            data_list.append(data)

    num_data_files = len(data_list)
    print "Processed %d files" % num_data_files

    # Go through all the files, and find the unique keys.
    data_keys = []

    for data in data_list:
        data_keys = data_keys + data.point_map.keys()
        print "After proc of data %s: now have %d keys" % (data.get_desc(),
                                                           len(data_keys))

    
    data_keys = sorted(set(data_keys))
    plot_keys = sorted(set([PerfDataPoint.extract_plot_key(k) for k in data_keys]))

    print "Total number of data_keys: %d" % len(data_keys)
    print "Total number of plot keys: %d" % len(plot_keys)


    # Create a list of pairs of (desc, plot_map)
    #  desc is a string, describing a line to plot
    #  plot_map is a map from pkey object to set of PerfDataPoint objects.

    all_maps = []
    for data in data_list:
        local_plot_map = { }
    # Scan through each data point, add to the correct list based on
    # pkey.
        for key in data.point_map.keys():
            pkey = PerfDataPoint.extract_plot_key(key)
            if pkey in local_plot_map:
                local_plot_map[pkey] = local_plot_map[pkey] + [ data.point_map[key] ]
            else:
                local_plot_map[pkey] = [ data.point_map[key] ]

        all_maps.append((data.get_desc(),
                         local_plot_map))

    # Generate a gnuplot for each plot key and data set.
    generate_all_speedup_plots(plot_keys, all_maps)


# Run if we aren't importing.             
if __name__ == "__main__":
    main(sys.argv)



